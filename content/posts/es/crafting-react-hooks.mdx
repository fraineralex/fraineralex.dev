---
title: 'Conquistando los Hooks en React: Una Gu√≠a Completa'
description: 'En este art√≠culo, revelar√© de manera clara y simplificada c√≥mo React Hooks puede hacer magia en tus proyectos, tal como me hubiera gustado aprender cuando los descubr√≠.'
date: '2024-01-24'
url: '/'
hero: '/images/blog/posts/cover/crafting-react-hooks.webp'
tags: ['react', 'javascript', 'typescript']
published: true
lang: 'es'
---

En este art√≠culo, revelar√© de manera clara y simplificada c√≥mo React Hooks puede hacer magia en tus proyectos, tal como me hubiera gustado aprender cuando los descubr√≠.

### ü™ù Hooks: La magia de React

En React, los hooks son utilidades que nos permiten ejecutar c√≥digo arbitrario en nuestros componentes basados en acciones espec√≠ficas. Los hooks proporcionan una forma de reutilizar la l√≥gica de estado y efectos secundarios en componentes funcionales de manera m√°s simple y declarativa.

> **üö® Importante:** Esta gu√≠a utiliza fragmentos de c√≥digo `TypeScript` para ilustrar los conceptos. Si no est√°s familiarizado con TypeScript, si√©ntete libre de ignorar la escritura de tipos en los ejemplos.

## üå± Hooks B√°sicos

Esta gu√≠a de referencia discutir√° todos los hooks disponibles nativamente en React, pero primero, comencemos con los hooks b√°sicos de React: `useState`, `useEffect` y `useContext`.

![Imagen de los hooks b√°sicos de React](https://fraineralex.dev/images/blog/posts/content/basic-hooks.webp)

## ‚ö° useState

Es un hook que permite a los componentes funcionales gestionar y mantener su estado interno. Puedes usarlo para declarar variables de estado y acceder a ellas en tus componentes funcionales.

**La firma para el hook `useState` es la siguiente:**

```tsx
const [state, setState] = useState(initialState)
```

Aqu√≠, `state` y `setState` se refieren al valor del estado y a la funci√≥n de actualizaci√≥n devuelta al invocar `useState` con alg√∫n `initialState`.

Es importante tener en cuenta que cuando tu componente se renderiza por primera vez e invoca `useState`, el `initialState` es el estado devuelto por `useState`.

Adem√°s, para actualizar el estado, la funci√≥n de actualizaci√≥n del estado `setState` debe invocarse con un nuevo valor de estado, como se muestra a continuaci√≥n:

```tsx
setState(newValue)
```

Al hacer esto, se encola un nuevo renderizado del componente. `useState` garantiza que el valor del `state` siempre ser√° el m√°s reciente despu√©s de aplicar actualizaciones.

**Ejemplo de uso de `useState` en un componente React acerca de la tarjeta de seguimiento de X:**

```tsx
export function XFollowCard({ fullName, username, initialFollowing }: Props) {
  const [following, setFollowing] = useState(initialFollowing) // <-- Definici√≥n

  const text = following ? 'Siguiendo' : 'Seguir'

  const buttonClassName = following
    ? 'tw-followCard-button is-following'
    : 'tw-followCard-button'

  const handleClick = () => {
    setFollowing(!following) // Cambiando el estado
  }

  return (
    <article className='tw-followCard'>
      <header className='tw-followCard-header'>
        <img
          className='tw-followCard-avatar'
          alt='user avatar'
          src={`https://unavatar.io/${username}`}
        />
        <div className='tw-followCard-info'>
          <strong>{fullName}</strong>
          <span className='tw-followCard-infoUserName'>@{username}</span>
        </div>
      </header>

      <aside>
        <button className={buttonClassName} onClick={handleClick}>
          <span className='tw-followCard-text'>{text}</span>
          <span className='tw-followCard-stopFollow'>Dejar de seguir</span>
        </button>
      </aside>
    </article>
  )
}

```

## üé¨ useEffect

Es un hook de React que permite realizar efectos secundarios en componentes funcionales. Puedes usarlo para ejecutar c√≥digo en respuesta a cambios en el componente, como hacer solicitudes a API, suscribirte a eventos o actualizar el DOM. `useEffect` recibe una funci√≥n como argumento y la ejecuta despu√©s de que el componente se renderiza o cuando ciertas dependencias cambian.

La firma b√°sica de `useEffect` es la siguiente:

```tsx
useEffect(() => {
  //...
})

```

**Ejemplo de uso de `useEffect` en un componente React:**

```tsx
const CAT_IMAGE_URL_PREFIX = 'https://cataas.com'

export function useCatImage({ fact }: { fact: string }) {
  const [imageUrl, setImageUrl] = useState()

  useEffect(() => {
    if (!fact) return

    const firstThreeWords = fact.split(' ', 3).join(' ')

    fetch(
      `${CAT_IMAGE_URL_PREFIX}/cat/says/${firstThreeWords}?size=50&color=red&json=true`
    )
      .then((res) => res.json())
      .then((response) => {
        const { url } = response
        setImageUrl(url)
      })
  }, [fact])

  return { imageUrl: `${CAT_IMAGE_URL_PREFIX}${imageUrl}` }
}

```

### üßπ Limpiando un efecto

Algun c√≥digo imperativo necesita ser limpiado para prevenir fugas de memoria. Por ejemplo, las suscripciones deben ser limpiadas, los temporizadores deben ser invalidados, etc. Para hacer esto, se retorna una funci√≥n desde el callback pasado a `useEffect`:

```tsx
useEffect(() => {
  const subscription = props.apiSubscription()

  return () => {
    // limpiar la suscripci√≥n
    subscription.unsubscribeApi()
  }
})

```

Se garantiza que la funci√≥n de limpieza se invoque antes de que el componente sea eliminado de la interfaz de usuario.

### ‚ö†Ô∏è Evitar bucles infinitos

Cuando se utiliza `useEffect` en React, es crucial evitar bucles infinitos que pueden surgir de configuraciones incorrectas del efecto. Un error com√∫n es modificar el estado dentro del cuerpo del efecto de una manera que desencadene renderizaciones infinitas.

> **Causa com√∫n de bucles infinitos:** Modificaci√≥n directa del estado

```tsx
useEffect(() => {
  // Incorrecto: Modificar el estado dentro del cuerpo del efecto
  setCounter(counter + 1)
}, [counter])

```

Este ejemplo provoca un bucle infinito al actualizar el estado dentro del efecto, desencadenando nuevas renderizaciones y reejecutando el efecto.

### ‚úÖ Soluci√≥n

```tsx
useEffect(() => {
  // Correcto: Sin dependencias en el array, evitando el bucle infinito
  setCounter(counter + 1)
}, [])

```

Evita bucles infinitos asegur√°ndote de que las dependencias en el array de dependencias de `useEffect` sean estables y no cambien dentro del efecto.

## ü§ù useContext

El problema que resuelve `useContext` radica en la necesidad de pasar datos a trav√©s de la jerarqu√≠a de componentes sin recurrir al prop drilling, que es cuando se pasan props manualmente a trav√©s de varios niveles de componentes. Este enfoque puede volverse engorroso e impr√°ctico a medida que la aplicaci√≥n crece, ya que cada componente intermedio tiene que transmitir las props, generando un c√≥digo menos limpio y propenso a errores.

### ‚ùå Prop Drilling: El Desaf√≠o

Imagina un escenario en el que tenemos un `ComponentA` que necesita pasar datos a `ComponentD`. El prop drilling tradicional implicar√≠a pasar las props a trav√©s de todos los componentes intermedios, incluso si `ComponentB` y `ComponentC` no necesitan esos datos.

```tsx
// ComponentA.tsx
const ComponentA = ({ dataForD }: Props) => {
  return <ComponentB dataForD={dataForD} />
}

// ComponentB.tsx
const ComponentB = ({ dataForD }: Props) => {
  return <ComponentC dataForD={dataForD} />
}

// ComponentC.tsx
const ComponentC = ({ dataForD }: Props) => {
  return <ComponentD dataForD={dataForD} />
}

// ComponentD.tsx
const ComponentD = ({ dataForD }: Props) => {
  // Todo para usar el dataForD aqu√≠
}

```

Este proceso, conocido como prop drilling, puede volverse inmanejable y complicado a medida que se agregan m√°s componentes a la jerarqu√≠a.

### ‚úÖ Soluci√≥n: ¬°`useContext` al Rescate!

`useContext` simplifica en gran medida esta tarea al permitirnos crear y consumir un contexto sin pasar manualmente las props a trav√©s de cada componente. Primero, creamos un contexto usando `createContext`:

```tsx
// ThemeContext.ts
import { createContext } from 'react'
export const ThemeContext = createContext()

```

Luego, usamos el componente `Provider` para envolver nuestro √°rbol de componentes con el valor deseado:

```tsx
// App.tsx
import React from 'react'
import { ThemeContext } from './ThemeContext'

const App = () => {
  return (
    <ThemeContext.Provider value='dark'>
      {/* Componentes anidados aqu√≠ */}
    </ThemeContext.Provider>
  )
}

```

Finalmente, en cualquier componente dentro de este contexto, podemos usar `useContext` para acceder a los datos sin pasar manualmente las props:

```tsx
// Button.tsx
import React, { useContext } from 'react'
import { ThemeContext } from './ThemeContext'

export const Button = () => {
  const theme = useContext(ThemeContext)
  return <button className={theme}>Haz clic aqu√≠</button>
}

```

> Ten en cuenta que el valor pasado a `useContext` debe ser el objeto de contexto, es decir, el valor devuelto al invocar `React.createContext`, no `ContextObject.Provider` o `ContextObject.Consumer`.

Esta soluci√≥n evita el engorroso prop drilling y proporciona una forma m√°s limpia y eficiente de compartir datos entre componentes en una aplicaci√≥n de React. `useContext` hace que la gesti√≥n de datos sea m√°s elegante y f√°cil de mantener.

¬°Adi√≥s, prop drilling! üëã

## üåü Hooks Adicionales

Los siguientes hooks son variantes de los hooks b√°sicos discutidos en las secciones anteriores. Si eres nuevo en los hooks, no te molestes en aprender estos por ahora. Solo son necesarios para casos espec√≠ficos.

![Imagen de hooks adicionales de React](https://fraineralex.dev/images/blog/posts/content/additional-hooks.webp)

## üìå useRef

`useRef` en React es un hook que facilita la creaci√≥n de referencias mutables. A diferencia de `useState`, `useRef` no desencadena la actualizaci√≥n de componentes cuando su valor cambia, convirti√©ndolo en una herramienta poderosa para almacenar datos que no afectan directamente la interfaz de usuario.

As√≠ es como se utiliza el hook¬†`useRef`:

```tsx
import { useRef } from 'react'

const MyComponent = () => {
  const myRef = useRef(initialValue)
  // ...
}

```

### ü•∑üèª Desaf√≠o

El problema que resuelve `useRef` se hace evidente cuando necesitamos actualizar valores sin activar una actualizaci√≥n visual del componente. Para ilustrar esto, consideremos un escenario de b√∫squeda de pel√≠culas:

```tsx
export function useMovies({ search }: { search: string }) {
  const [movies, setMovies] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)

  const getMovies = async () => {
    // ‚ùå Esto es una mala pr√°ctica porque estamos obteniendo
    // las pel√≠culas y volviendo a renderizar el componente
    // incluso si la b√∫squeda es la misma que la anterior.

    try {
      setLoading(true)
      setError(null)
      const newMovies = await searchMovies({ search })
      setMovies(newMovies)
    } catch (error: any) {
      setError(error.message)
    } finally {
      setLoading(false)
    }
  }

  return { movies, getMovies, loading, error }
}

```

En este caso, usar `useState` para el t√©rmino de b√∫squeda provoca renderizaciones innecesarias cada vez que cambia el t√©rmino de b√∫squeda. Aqu√≠ es donde `useRef` se convierte en una soluci√≥n eficiente al permitirnos actualizar `search` sin afectar la interfaz de usuario:

```tsx
export function useMovies({ search }: { search: string }) {
  const [movies, setMovies] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  const previousSearch = useRef(search) // <-- Define una ref

  const getMovies = async () => {
    // ‚úÖ Si la b√∫squeda actual es igual a la anterior, retorna
    if (previousSearch.current === search) return

    try {
      setLoading(true)
      setError(null)
      previousSearch.current = search
      const newMovies = await searchMovies({ search })
      setMovies(newMovies)
    } catch (error: any) {
      setError(error.message)
    } finally {
      setLoading(false)
    }
  }

  return { movies, getMovies, loading, error }
}

```

Con esta implementaci√≥n, `useRef` ayuda a gestionar el valor de `search` sin causar actualizaciones visuales no deseadas, mejorando la eficiencia y la experiencia del usuario.

## üß† useMemo

El hook `useMemo` en React es una herramienta poderosa para optimizar el rendimiento al memorizar el resultado de una funci√≥n. Su prop√≥sito principal es evitar c√°lculos innecesarios, reutilizando el valor calculado anteriormente si las dependencias no han cambiado.

As√≠ es como se utiliza el hook¬†`useMemo`:

```tsx
const readTime = useMemo(() => {
  const wordsPerMinute = 200
  const words = text.trim().split(/\s+/).length
  const value = Math.ceil(words / wordsPerMinute)
  return `${value} min de lectura`
}, [text]) // solo recalcular si cambia el texto
```

El problema que aborda `useMemo` se hace evidente cuando necesitamos realizar c√°lculos costosos en un componente, pero esos c√°lculos no son necesarios cada vez que el componente se renderiza. Tomemos el ejemplo del componente `Counter`:

```tsx
export function Counter({ count }: { count: number }) {
  const double = count * 2 // Costoso c√°lculo realizado en cada renderizaci√≥n

  return (
    <div>
      <p>Contador: {count}</p>
      <p>Doble: {double}</p>
    </div>
  )
}

```

En este caso, el valor doble se recalcula en cada renderizaci√≥n, incluso si `count` no ha cambiado. `useMemo` resuelve esto al memorizar el resultado del c√°lculo solo cuando las dependencias, en este caso, la propiedad `count`, han cambiado:

```tsx
import { useMemo } from 'react'

export function Counter({ count }: { count: number }) {
  const double = useMemo(() => count * 2, [count])

  return (
    <div>
      <p>Contador: {count}</p>
      <p>Doble: {double}</p>
    </div>
  )
}

```

Con `useMemo`, si la propiedad `count` no ha cambiado, se evita el rec√°lculo del doble y se reutiliza el valor calculado anteriormente. Esto mejora significativamente la eficiencia del componente, especialmente en situaciones donde los c√°lculos son m√°s intensivos en recursos.

## ‚ôªÔ∏è useCallback

El hook `useCallback` en React proporciona una forma de memorizar funciones. La principal ventaja es evitar la creaci√≥n de nuevas funciones en cada renderizaci√≥n, devolviendo la funci√≥n memorizada previamente si las dependencias no han cambiado.

As√≠ es como se utiliza el hook¬†`useCallback`:

```tsx
const callbackMemorizado = useCallback(callback, arrayDependencia)
```

El problema que aborda `useCallback` se hace evidente cuando necesitamos pasar funciones a componentes hijos y queremos evitar la creaci√≥n de nuevas instancias de esas funciones en cada renderizaci√≥n. Tomemos el ejemplo del componente `Counter`:

```tsx
function Counter({ count, onIncrement }: Props) {
  const handleIncrement = () => {
    onIncrement(count)
  }

  return (
    <div>
      <p>Contador: {count}</p>
      <button onClick={handleIncrement}>Incrementar</button>
    </div>
  )
}

```

En este caso, `handleIncrement` se recrea en cada renderizaci√≥n, lo cual no es eficiente, especialmente si `onIncrement` y `count` no han cambiado. `useCallback` aborda esto al memorizar la funci√≥n solo cuando cambian las dependencias:

```tsx
import { useCallback } from 'react'

export function Counter({ count, onIncrement }: Props) {
  const handleIncrement = useCallback(() => {
    onIncrement(count)
  }, [count, onIncrement

]) // solo recrear si count u onIncrement cambian

  return (
    <div>
      <p>Contador: {count}</p>
      <button onClick={handleIncrement}>Incrementar</button>
    </div>
  )
}

```

Con `useCallback`, si `count` o `onIncrement` no han cambiado, se evita la creaci√≥n de una nueva funci√≥n y se reutiliza la funci√≥n calculada previamente. Esto mejora la eficiencia y contribuye a un rendimiento del componente m√°s √≥ptimo.

## üè∑Ô∏è useId

`useId` es un hook de React dise√±ado para generar identificadores √∫nicos, ideales para asignarlos a atributos de etiquetas HTML. Esta pr√°ctica resulta especialmente √∫til para mejorar la accesibilidad al establecer relaciones espec√≠ficas entre elementos.

As√≠ es como se utiliza el hook `useId`:

```tsx
const passwordHintId = useId()
```

A continuaci√≥n, el ID generado se utiliza en diferentes atributos:

```tsx
<>
  <input type='password' aria-describedby={passwordHintId} />
  <p id={passwordHintId}>
</>
```

El problema que aborda `useId` surge cuando necesitamos asignar identificadores √∫nicos a elementos HTML, especialmente en situaciones en las que un componente puede aparecer m√∫ltiples veces en la pantalla. Tomemos el ejemplo del componente `PasswordField`:

```tsx
import { useId } from 'react'

export function PasswordField() {
  const passwordHintId = useId()

  return (
    <>
      <label>
        Contrase√±a:
        <input type='password' aria-describedby={passwordHintId} />
      </label>
      <p id={passwordHintId}>
        La contrase√±a debe tener 18 caracteres y contener caracteres especiales.
      </p>
    </>
  )
}
```

En este caso, `useId` se utiliza para generar un ID √∫nico (`passwordHintId`) que se asigna tanto al atributo `aria-describedby` del input como al `id` del p√°rrafo. Esto asegura que aunque `PasswordField` aparezca varias veces en la pantalla, los IDs generados no entrar√°n en conflicto.

```tsx
export default function App() {
  return (
    <>
      <h2>Elegir contrase√±a</h2>
      <PasswordField />
      <h2>Confirmar contrase√±a</h2>
      <PasswordField />
    </>
  )
}
```

En el componente `App`, donde se usa `PasswordField` dos veces, `useId` asegura que los identificadores generados autom√°ticamente eviten duplicados y proporcionen una soluci√≥n robusta para asignar IDs √∫nicos en contextos repetidos. Esto contribuye a mejorar la accesibilidad y consistencia en la aplicaci√≥n.

## üïπÔ∏è useReducer

`useReducer` es un hook de React dise√±ado para gestionar el estado de un componente mediante un enfoque basado en acciones y reducciones, similar al patr√≥n utilizado en Redux. Este hook se prefiere sobre `useState` cuando el estado de un componente es m√°s complejo o cuando las actualizaciones de estado dependen del estado anterior o de acciones previas.

`useReducer` toma dos argumentos: una funci√≥n de reducci√≥n y el estado inicial. La funci√≥n de reducci√≥n recibe dos argumentos: el estado actual y una acci√≥n que describe c√≥mo deber√≠a cambiar el estado. La funci√≥n de reducci√≥n devuelve el nuevo estado.

**As√≠ es como se utiliza el hook `useReducer`:**

```tsx
const [state, dispatch] = useReducer(reducer, argumentoInicial, init)
```

El problema que aborda `useReducer` surge cuando el estado de un componente se vuelve m√°s complejo y las actualizaciones de estado dependen de m√∫ltiples factores o acciones. Tomemos el ejemplo del componente `Counter`:

```tsx
import { useState } from 'react'

export const Counter = () => {
  const [count, setCount] = useState(0)

  const handleIncrement = () => {
    setCount(count + 1)
  }

  const handleDecrement = () => {
    setCount(count - 1)
  }

  return (
    <div>
      <p>Contador: {count}</p>
      <button onClick={handleIncrement}>Incrementar</button>
      <button onClick={handleDecrement}>Decrementar</button>
    </div>
  )
}
```

En este ejemplo, usamos `useState` para gestionar el estado del contador. Si bien esto puede funcionar para casos simples, a medida que la l√≥gica del estado se vuelve m√°s compleja o depende de acciones previas, el c√≥digo puede volverse m√°s dif√≠cil de mantener. `useReducer` proporciona una estructura m√°s organizada y una soluci√≥n m√°s escalable para manejar estados y acciones complejas en situaciones donde el c√≥digo podr√≠a volverse confuso usando solo `useState`. Abordar√≠amos este problema con `useReducer` de la siguiente manera:

```tsx
// Define la funci√≥n de reducci√≥n
const counterReducer = (state: State, action: Action) => {
  switch (action.type) {
    case 'incrementar':
      return { count: state.count + 1 }
    case 'decrementar':
      return { count: state.count - 1 }
    default:
      return state
  }
}

export const Counter = () => {
  // Usa useReducer para gestionar el estado del contador
  const [state, dispatch] = useReducer(counterReducer, { count: 0 })

  return (
    <div>
      <p>Contador: {state.count}</p>
      <button onClick={() => dispatch({ type: 'incrementar' })}>Incrementar</button>
      <button onClick={() => dispatch({ type: 'decrementar' })}>Decrementar</button>
    </div>
  )
}
```

## ‚ú® useImperativeHandle

`useImperativeHandle` en React es una herramienta √∫til cuando necesitas controlar y personalizar la interfaz externa de un componente funcional, especialmente al trabajar con refs. Imagina el desaf√≠o al que te enfrentar√≠as sin este gancho.

### ü§î Desaf√≠o Sin `useImperativeHandle`:

Supongamos que tenemos un componente funcional llamado `FancyInput` que encapsula un campo de texto. Queremos que el componente padre acceda y manipule el valor del campo directamente y tambi√©n active el enfoque en ese campo. Sin `useImperativeHandle`, podr√≠amos terminar con un c√≥digo menos eficiente y propenso a errores.

```tsx
export const FancyInput = () => {
  const inputRef = useRef<HTMLInputElement>(null)

  const focusInput = () => {
    if (inputRef.current) {
      inputRef.current.focus()
    }
  }

  return (
    <div>
      <input ref={inputRef} />
      {/* Desaf√≠o: ¬øC√≥mo exponer el m√©todo `focusInput` al componente padre? */}
    </div>
  )
}

```

En este escenario, exponer el m√©todo `focusInput` al componente padre ser√≠a una tarea desafiante e inelegante. Aqu√≠ es donde entra en juego `useImperativeHandle`.

### ‚úÖ Soluci√≥n con `useImperativeHandle`:

```tsx
export const FancyInput = forwardRef((props, ref) => {
  const inputRef = useRef<HTMLInputElement>(null)

  // Usa useImperativeHandle para personalizar la interfaz externa
  useImperativeHandle(ref, () => ({
    focus: () => {
      if (inputRef.current) {
        inputRef.current.focus()
      }
    },
    getValue: () => {
      return inputRef.current ? inputRef.current.value : ''
    },
  }))

  return (
    <div>
      <input ref={inputRef} />
    </div>
  )
})

```

Con `useImperativeHandle`, ahora podemos exponer selectivamente las funciones que queremos que el componente padre utilice. Esta soluci√≥n mejora la claridad del c√≥digo y proporciona una interfaz externa m√°s eficiente y controlada.

## üß© useLayoutEffect

`useLayoutEffect` en React es un gancho potente que te permite realizar operaciones s√≠ncronas despu√©s de que se hayan completado todas las mutaciones en el DOM, pero antes de que el navegador repinte la pantalla. Imagina el desaf√≠o al que te enfrentar√≠as sin este gancho.

### ü§î Desaf√≠o Sin `useLayoutEffect`:

Imagina un escenario en el que queremos medir las dimensiones de un elemento DOM y, bas√°ndonos en esas dimensiones, realizar ciertas acciones en nuestro componente funcional `ResizableBox`. Sin `useLayoutEffect`, podr√≠amos tener problemas al realizar estas mediciones de manera as√≠ncrona.

```tsx
export const ResizableBox = () => {
  const boxRef = useRef<HTMLDivElement>(null)
  const [boxWidth, setBoxWidth] = useState(0)

  useEffect(() => {
    // Desaf√≠o: ¬øC√≥mo medir las dimensiones de boxRef de manera s√≠ncrona?
    // Las mediciones pueden no estar disponibles de inmediato.
    // Esto puede causar problemas si dependemos de las dimensiones para realizar acciones.
  }, [])

  return <div ref={boxRef}>{/* Contenido de la caja redimensionable */}</div>
}

```

En este escenario, realizar mediciones s√≠ncronas de las dimensiones de `boxRef` es desafiante con `useEffect` porque las mediciones pueden no estar disponibles de inmediato. Aqu√≠ es donde entra en juego `useLayoutEffect`.

### ‚úÖ Soluci√≥n con `useLayoutEffect`:

```tsx
export const ResizableBox = () => {
  const boxRef = useRef<HTMLDivElement>(null)
  const [boxWidth, setBoxWidth] = useState(0)

  useLayoutEffect(() => {
    // Usa useLayoutEffect para medir las dimensiones de boxRef de manera s√≠ncrona
    if (boxRef.current) {
      setBoxWidth(boxRef.current.offsetWidth)
    }
  }, [])

  return <div ref={boxRef}>{/* Contenido de la caja redimensionable */}</div>
}

```

Con `useLayoutEffect`, podemos realizar mediciones s√≠ncronas despu√©s de que el navegador haya completado todas las mutaciones en el DOM pero antes de repintar la pantalla. Esto asegura que las mediciones est√©n disponibles de inmediato y evita problemas potenciales relacionados con la asincron√≠a.

## üêû useDebugValue

`useDebugValue` en React es un gancho especializado dise√±ado para mejorar la experiencia de depuraci√≥n al proporcionar informaci√≥n adicional sobre el estado de un componente. Su principal utilidad es facilitar la identificaci√≥n de componentes en las herramientas de desarrollo del navegador.

La firma b√°sica para `useDebugValue` es la siguiente:

```tsx
useDebugValue(value)
```

Al depurar una aplicaci√≥n de React, es com√∫n enfrentarse al desaf√≠o de identificar r√°pidamente el componente de inter√©s dentro de las herramientas de desarrollo del navegador. Sin `useDebugValue`, la informaci√≥n sobre un componente puede ser limitada y no espec√≠fica.

**As√≠ es c√≥mo se usa el gancho `useDebugValue`:**

### 1. Agregar un Nombre Descriptivo:

```tsx
import { useDebugValue } from 'react'

const useCustomHook = () => {
  const state =
    /* l√≥gica del gancho */

    // Proporcionar un nombre descriptivo para facilitar la identificaci√≥n en las herramientas de desarrollo
    useDebugValue('Custom Hook')

  return state
}

```

### 2. Mostrar Contenido de un Array:

```tsx
import { useDebugValue } from 'react'

const useArrayHook = (array: string[]) => {
  // l√≥gica del gancho

  // Mostrar el contenido del array en las herramientas de desarrollo
  useDebugValue(array.join(', '))

  return /* resultado */
}

```

### 3. Utilizar Informaci√≥n del Estado:

```tsx
import { useState, useDebugValue } from 'react'

const useCounter = () => {
  const [count, setCount] = useState(0)

  // Utilizar el valor del contador como informaci√≥n en las herramientas de desarrollo
  useDebugValue(`Contador: ${count}`)

  return [count, setCount]
}

```

Al usar `useDebugValue`, puedes personalizar la informaci√≥n que se muestra sobre tu gancho o componente en las herramientas de desarrollo, facilitando su identificaci√≥n y depuraci√≥n durante el desarrollo.

## üöÄ Conclusi√≥n

En esta exploraci√≥n de React Hooks, desde los conceptos m√°s b√°sicos hasta los m√°s avanzados, conf√≠o en que hayas descubierto el fascinante mundo que estos ganchos ofrecen para simplificar y potenciar tus desarrollos en React. ¬°Feliz codificaci√≥n! ‚ú®

### üîó Referencias

- https://react.dev/reference/react
- [https://www.youtube.com/@midulive](https://youtube.com/playlist?list=PLUofhDIg_38q4D0xNWp7FEHOTcZhjWJ29&si=38k-uyCK8hlf7DIk)

### üåê Recursos Adicionales

- [Documentaci√≥n de React Hooks: Una versi√≥n f√°cil de leer](https://blog.logrocket.com/react-hooks-cheat-sheet-solutions-common-problems/)